'use strict'

const data = require('./data.json')

function computeMachines(args) {
    const {inputAmount, recipeInputAmount, recipeOutputAmount, recipeOutputFluidAmount, perFloor, powerShards} = args,
        floors = Math.ceil(inputAmount / (recipeInputAmount * perFloor * (1 + powerShards * 0.5))),
        machines = floors * perFloor,
        clock = inputAmount / (machines * recipeInputAmount),
        usedPowerShards = clock > 1 ? Math.ceil((clock - 1) * 2) : 0,
        outputAmount = recipeOutputAmount * machines * clock,
        outputFluidAmount = recipeOutputFluidAmount * machines * clock
    return {floors, machines, clock, outputAmount, outputFluidAmount, perFloor, powerShards: usedPowerShards * machines}
}

function computeGenerators(generator, fuel, amount) {
    // TODO: power shards for the generators are probably a pain because the clock acts on the power, not the input
    // need to add power shards to the water extractors though
    const machines = Math.ceil(amount / fuel.amount),
        clock = Math.pow(amount / (machines * fuel.amount), generator.powerProductionExponent),
        power = generator.powerProduction * Math.pow(clock, 1 / generator.powerProductionExponent) * machines,
        water = power * generator.waterToPowerRatio * 60 / 1000,
        extractors = Math.ceil(water / 120),
        extractorClock = water / (extractors * 120)
    return {machines, clock, power, water, extractors, extractorClock}
}

function roundClock(clock) {
    return Math.round(clock * 10000) / 100
}

// create comment string to display next to machine nodes
function renderMachines(machines, names) {
    const clock = roundClock(machines.clock)
    let output = ''
    if (machines.perFloor > 1) {
        output = `${machines.floors} floors of ${machines.perFloor} ${names.machinesName} @ ${clock}%`
    } else {
        output = `${machines.machines} ${names.machinesName} @ ${clock}%`
    }
    if (machines.powerShards > 0) output += ` (using ${machines.powerShards} power shards)`
    if (machines.outputAmount) output += `\nProducing ${machines.outputAmount} ${names.productName}/min`
    if (machines.outputFluidAmount) output += `\nProducing ${machines.outputFluidAmount} m³/min of ${names.fluidName}`
    return output
}

// create comment string to display next to generator nodes
function renderGenerators(generators, name) {
    let output = `${generators.machines} ${name} @ ${roundClock(generators.clock)}%
Producing ${Math.round(generators.power)} MW`
    if (generators.water > 0) {
        output += `\nNeeds ${Math.round(generators.water * 100) / 100} m³/min of Water from ${generators.extractors} extractors @ ${roundClock(generators.extractorClock)}%`
    }
    return output
}

// create string to display inputs
function renderInputs(inputs) {
    let result = []
    for (let slug in inputs) result.push(`${inputs[slug]} ${data.items[slug]}/min`)
    return result.join(' + ')
}
// create string to display recipe inputs
function renderRecipe(recipe) {
    let result = []
    for (let slug in recipe.ingredients) {
        let ingredient = recipe.ingredients[slug]
        result.push(`${ingredient.amount} ${ingredient.name}/min`)
    }
    return `Recipe: ${result.join(' + ')}`
}
// create string to display recipe inputs for refineries etc.
function renderFluidRecipe(recipe) {
    let result = []
    if (recipe.ingredients.items) result.push(`${recipe.ingredients.items.amount} ${recipe.ingredients.items.name}/min`)
    if (recipe.ingredients.fluid) result.push(`${recipe.ingredients.fluid.amount} m³/min of ${recipe.ingredients.fluid.name}`)
    return `Recipe: ${result.join(' + ')}`
}

// check that inputs are valid (Assemblers, Manufacturers, etc.)
function checkInputs(inputNodes, machines, recipe) {
    let inputs = {}, expectedInputs = {}
    for (let slug in recipe.ingredients) {
        expectedInputs[slug] = recipe.ingredients[slug].amount * machines.machines * machines.clock
    }
    for (let input of inputNodes) {
        if (input.value.slug) inputs[input.value.slug] = input.value.amount
    }
    const inputsString = renderInputs(inputs)
    for (let slug in expectedInputs) {
        if (inputs[slug] == expectedInputs[slug]) delete inputs[slug]
        else throw {
            error: "Invalid inputs or amount mismatch!",
            inputs: inputsString,
            expectedInputs: renderInputs(expectedInputs),
            recipe: renderRecipe(recipe)
        }
    }
}

module.exports = {
    data, computeMachines, computeGenerators, renderMachines, renderGenerators,
    checkInputs, renderRecipe, renderFluidRecipe
}
